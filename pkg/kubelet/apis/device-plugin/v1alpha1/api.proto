// To regenerate api.pb.go run hack/update-generated-runtime.sh
syntax = 'proto3';

package deviceplugin;

import "github.com/gogo/protobuf/gogoproto/gogo.proto";

option (gogoproto.goproto_stringer_all) = false;
option (gogoproto.stringer_all) =  true;
option (gogoproto.goproto_getters_all) = true;
option (gogoproto.marshaler_all) = true;
option (gogoproto.sizer_all) = true;
option (gogoproto.unmarshaler_all) = true;
option (gogoproto.goproto_unrecognized_all) = false;


service PluginRegistration {
	rpc Register(RegisterRequest) returns (RegisterResponse) {}
}

service DeviceManager {
	rpc Init(Empty) returns (Empty) {}

	rpc Discover(Empty) returns (stream Device) {}
	rpc Monitor(Empty) returns (stream DeviceHealth) {}

	rpc Allocate(AllocateRequest) returns (AllocateResponse) {}
	rpc Deallocate(DeallocateRequest) returns (Error) {}
}

message RegisterRequest {
	// Version of the API the Device Plugin was built against
	string version = 1;
	// Name of the unix socket the device plugin is listening on
	string unixsocket = 2;
	// Name of the devices the device plugin wants to register
	// A device plugin can only register one kind of devices
	string kind = 3;
}

message RegisterResponse {
	// Minimum version the Kubelet API supports.
	string version = 1;
	// Kubelet fills this field to false if the RegistereRequest does
	// not support the version
	string error = 2;
}

message AllocateRequest {
	repeated Device devices = 1;
}

message AllocateResponse {
	// List of environment variable to set in the container.
	repeated KeyValue envs = 1;
	// Mounts for the container.
	repeated Mount mounts = 2;
	// Devices for the container.
	repeated ContainerDevice devices = 3;
}

message DeallocateRequest {
	repeated Device devices = 1;
}

// Mount specifies a host volume to mount into a container.
message Mount {
    // Path of the mount within the container.
    string container_path = 1;
    // Path of the mount on the host.
    string host_path = 2;
    // If set, the mount is read-only.
    bool readonly = 3;
    // If set, the mount needs SELinux relabeling.
    bool selinux_relabel = 4;
}

message KeyValue {
    string key = 1;
    string value = 2;
}

message ContainerDevice {
    // Path of the device within the container.
    string container_path = 1;
    // Path of the device on the host.
    string host_path = 2;
    // Cgroups permissions of the device, candidates are one or more of
    // * r - allows container to read from the specified device.
    // * w - allows container to write to the specified device.
    // * m - allows container to create device files that do not yet exist.
    string permissions = 3;
}

message Error {
	bool error = 1;
	string reason = 2;
}

/* E.g:
* struct Device {
*    Kind: "nvidia-gpu"
*    Name: "GPU-fef8089b-4820-abfc-e83e-94318197576e"
*    Properties: {
*        "Family": "Pascal",
*        "Memory": "4G",
*        "ECC"   : "True",
*    }
*}
*/
message Device {
	string Kind = 1;
	string Name = 2;
	map<string, string> properties = 4; // Could be [1, 1.2, 1G]
}

message DeviceHealth {
	string Name = 1;
	string Status = 2;
}

message Empty {
}
